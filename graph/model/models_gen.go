// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type AddMxid struct {
	Mxid string `json:"mxid"`
}

type AddToLists struct {
	Lists []string `json:"lists"`
	Entry string   `json:"entry"`
}

type CommentConnection struct {
	PageInfo *PageInfo      `json:"pageInfo"`
	Edges    []*CommentEdge `json:"edges"`
}

type CommentEdge struct {
	Node   *Comment `json:"node"`
	Cursor string   `json:"cursor"`
}

type CommentEntry struct {
	Entry   string `json:"entry"`
	Comment string `json:"comment"`
}

type CommentList struct {
	List    string `json:"list"`
	Comment string `json:"comment"`
}

type CreateEntry struct {
	Tags      []string `json:"tags"`
	PartOf    []string `json:"partOf"`
	HashValue string   `json:"hashValue"`
	Comment   *string  `json:"comment"`
}

type CreateList struct {
	Name        string   `json:"name"`
	Tags        []string `json:"tags"`
	Comment     *string  `json:"comment"`
	Maintainers []string `json:"maintainers"`
	Entries     []string `json:"entries"`
}

type EntryArrayFilter struct {
	ContainsAll []*EntryFilter `json:"containsAll"`
	ContainsOne []*EntryFilter `json:"containsOne"`
	Length      *int           `json:"length"`
}

type EntryConnection struct {
	PageInfo *PageInfo    `json:"pageInfo"`
	Edges    []*EntryEdge `json:"edges"`
}

type EntryEdge struct {
	Node   *Entry `json:"node"`
	Cursor string `json:"cursor"`
}

type EntryFilter struct {
	ID        *string            `json:"id"`
	HashValue *StringFilter      `json:"hashValue"`
	Tags      *StringArrayFilter `json:"tags"`
	AddedBy   *string            `json:"addedBy"`
	Timestamp *TimestampFilter   `json:"timestamp"`
	PartOf    *IDArrayFilter     `json:"partOf"`
}

type EntrySort struct {
	ID        *SortRule `json:"id"`
	HashValue *SortRule `json:"hashValue"`
	Timestamp *SortRule `json:"timestamp"`
	AddedBy   *SortRule `json:"addedBy"`
}

type HashCheckerConfigUpdate struct {
	ChatNotice    *bool            `json:"chatNotice"`
	HashCheckMode *HashCheckerMode `json:"hashCheckMode"`
}

type IDArrayFilter struct {
	ContainsAll []*string `json:"containsAll"`
	Length      *int      `json:"length"`
}

type IntFilter struct {
	Gt  *int `json:"gt"`
	Lt  *int `json:"lt"`
	Eq  *int `json:"eq"`
	Neq *int `json:"neq"`
}

type ListArrayFilter struct {
	ContainsAll []*ListFilter `json:"containsAll"`
	ContainsOne []*ListFilter `json:"containsOne"`
	Length      *int          `json:"length"`
}

type ListConnection struct {
	PageInfo *PageInfo   `json:"pageInfo"`
	Edges    []*ListEdge `json:"edges"`
}

type ListEdge struct {
	Node   *List  `json:"node"`
	Cursor string `json:"cursor"`
}

type ListFilter struct {
	ID          *string            `json:"id"`
	Name        *StringFilter      `json:"name"`
	Tags        *StringArrayFilter `json:"tags"`
	Maintainers *IDArrayFilter     `json:"maintainers"`
}

type ListSort struct {
	ID   *SortRule `json:"id"`
	Name *SortRule `json:"name"`
}

type ListSubscriptionUpdate struct {
	RoomID string `json:"roomId"`
	ListID string `json:"listId"`
}

type Login struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type PageInfo struct {
	HasPreviousPage bool   `json:"hasPreviousPage"`
	HasNextPage     bool   `json:"hasNextPage"`
	StartCursor     string `json:"startCursor"`
	EndCursor       string `json:"endCursor"`
}

type Register struct {
	Username string `json:"username"`
	Password string `json:"password"`
	MxID     string `json:"mxID"`
}

type RemoveFromLists struct {
	Lists []string `json:"lists"`
	Entry string   `json:"entry"`
}

type RemoveMxid struct {
	Mxid string `json:"mxid"`
}

type RoomConfigUpdate struct {
	ID              string                   `json:"id"`
	Deactivate      *bool                    `json:"deactivate"`
	Debug           *bool                    `json:"debug"`
	AdminPowerLevel *int                     `json:"adminPowerLevel"`
	HashChecker     *HashCheckerConfigUpdate `json:"hashChecker"`
}

type RoomConnection struct {
	PageInfo *PageInfo   `json:"pageInfo"`
	Edges    []*RoomEdge `json:"edges"`
}

type RoomEdge struct {
	Node   *Room  `json:"node"`
	Cursor string `json:"cursor"`
}

type RoomFilter struct {
	ID      *string `json:"id"`
	Active  *bool   `json:"active"`
	Debug   *bool   `json:"debug"`
	CanEdit *bool   `json:"canEdit"`
}

type SortRule struct {
	Direction SortDirection `json:"direction"`
}

type StringArrayFilter struct {
	ContainsAll []*string     `json:"containsAll"`
	ElemMatch   *StringFilter `json:"elemMatch"`
	Length      *int          `json:"length"`
}

type StringFilter struct {
	Eq    *string `json:"eq"`
	Neq   *string `json:"neq"`
	Regex *string `json:"regex"`
}

type TimestampFilter struct {
	After  *time.Time `json:"after"`
	Before *time.Time `json:"before"`
}

type UserArrayFilter struct {
	ContainsAll []*UserFilter `json:"containsAll"`
	ContainsOne []*UserFilter `json:"containsOne"`
	Length      *int          `json:"length"`
}

type UserConnection struct {
	PageInfo *PageInfo   `json:"pageInfo"`
	Edges    []*UserEdge `json:"edges"`
}

type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor string `json:"cursor"`
}

type UserFilter struct {
	ID                 *string            `json:"id"`
	Username           *StringFilter      `json:"username"`
	MatrixLinks        *StringArrayFilter `json:"matrixLinks"`
	PendingMatrixLinks *StringArrayFilter `json:"pendingMatrixLinks"`
	Admin              *bool              `json:"admin"`
}

type UserSort struct {
	ID       *SortRule `json:"id"`
	Username *SortRule `json:"username"`
	Admin    *SortRule `json:"admin"`
}

type HashCheckerMode string

const (
	HashCheckerModeNotice HashCheckerMode = "NOTICE"
	HashCheckerModeDelete HashCheckerMode = "DELETE"
	HashCheckerModeMute   HashCheckerMode = "MUTE"
	HashCheckerModeBan    HashCheckerMode = "BAN"
)

var AllHashCheckerMode = []HashCheckerMode{
	HashCheckerModeNotice,
	HashCheckerModeDelete,
	HashCheckerModeMute,
	HashCheckerModeBan,
}

func (e HashCheckerMode) IsValid() bool {
	switch e {
	case HashCheckerModeNotice, HashCheckerModeDelete, HashCheckerModeMute, HashCheckerModeBan:
		return true
	}
	return false
}

func (e HashCheckerMode) String() string {
	return string(e)
}

func (e *HashCheckerMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HashCheckerMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HashCheckerMode", str)
	}
	return nil
}

func (e HashCheckerMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortDirection string

const (
	SortDirectionAsc  SortDirection = "ASC"
	SortDirectionDesc SortDirection = "DESC"
)

var AllSortDirection = []SortDirection{
	SortDirectionAsc,
	SortDirectionDesc,
}

func (e SortDirection) IsValid() bool {
	switch e {
	case SortDirectionAsc, SortDirectionDesc:
		return true
	}
	return false
}

func (e SortDirection) String() string {
	return string(e)
}

func (e *SortDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirection", str)
	}
	return nil
}

func (e SortDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserRole string

const (
	UserRoleAdmin           UserRole = "ADMIN"
	UserRoleUser            UserRole = "USER"
	UserRoleUnauthenticated UserRole = "UNAUTHENTICATED"
)

var AllUserRole = []UserRole{
	UserRoleAdmin,
	UserRoleUser,
	UserRoleUnauthenticated,
}

func (e UserRole) IsValid() bool {
	switch e {
	case UserRoleAdmin, UserRoleUser, UserRoleUnauthenticated:
		return true
	}
	return false
}

func (e UserRole) String() string {
	return string(e)
}

func (e *UserRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRole", str)
	}
	return nil
}

func (e UserRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
