// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type CommentConnection struct {
	PageInfo *PageInfo      `json:"pageInfo"`
	Edges    []*CommentEdge `json:"edges"`
}

type CommentEdge struct {
	Node   *Comment `json:"node"`
	Cursor string   `json:"cursor"`
}

type EntryArrayFilter struct {
	ContainsAll []*EntryFilter `json:"containsAll"`
	ContainsOne []*EntryFilter `json:"containsOne"`
	Length      *int           `json:"length"`
}

type EntryConnection struct {
	PageInfo *PageInfo    `json:"pageInfo"`
	Edges    []*EntryEdge `json:"edges"`
}

type EntryEdge struct {
	Node   *Entry `json:"node"`
	Cursor string `json:"cursor"`
}

type EntryFilter struct {
	ID        *string            `json:"id"`
	HashValue *StringFilter      `json:"hashValue"`
	Tags      *StringArrayFilter `json:"tags"`
	AddedBy   *string            `json:"addedBy"`
	FileURL   *StringFilter      `json:"fileUrl"`
	Timestamp *TimestampFilter   `json:"timestamp"`
	PartOf    *IDArrayFilter     `json:"partOf"`
}

type EntrySort struct {
	ID        *SortRule `json:"id"`
	HashValue *SortRule `json:"hashValue"`
	Timestamp *SortRule `json:"timestamp"`
	AddedBy   *SortRule `json:"addedBy"`
}

type IDArrayFilter struct {
	ContainsAll []*string `json:"containsAll"`
	Length      *int      `json:"length"`
}

type IntFilter struct {
	Gt  *int `json:"gt"`
	Lt  *int `json:"lt"`
	Eq  *int `json:"eq"`
	Neq *int `json:"neq"`
}

type ListArrayFilter struct {
	ContainsAll []*ListFilter `json:"containsAll"`
	ContainsOne []*ListFilter `json:"containsOne"`
	Length      *int          `json:"length"`
}

type ListConnection struct {
	PageInfo *PageInfo   `json:"pageInfo"`
	Edges    []*ListEdge `json:"edges"`
}

type ListEdge struct {
	Node   *List  `json:"node"`
	Cursor string `json:"cursor"`
}

type ListFilter struct {
	ID          *string            `json:"id"`
	Name        *StringFilter      `json:"name"`
	Tags        *StringArrayFilter `json:"tags"`
	Maintainers *IDArrayFilter     `json:"maintainers"`
}

type ListSort struct {
	ID   *SortRule `json:"id"`
	Name *SortRule `json:"name"`
}

type Login struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type PageInfo struct {
	HasPreviousPage bool   `json:"hasPreviousPage"`
	HasNextPage     bool   `json:"hasNextPage"`
	StartCursor     string `json:"startCursor"`
	EndCursor       string `json:"endCursor"`
}

type SortRule struct {
	Direction SortDirection `json:"direction"`
}

type StringArrayFilter struct {
	ContainsAll []*string     `json:"containsAll"`
	ElemMatch   *StringFilter `json:"elemMatch"`
	Length      *int          `json:"length"`
}

type StringFilter struct {
	Eq    *string `json:"eq"`
	Neq   *string `json:"neq"`
	Regex *string `json:"regex"`
}

type TimestampFilter struct {
	After  *time.Time `json:"after"`
	Before *time.Time `json:"before"`
}

type UserArrayFilter struct {
	ContainsAll []*UserFilter `json:"containsAll"`
	ContainsOne []*UserFilter `json:"containsOne"`
	Length      *int          `json:"length"`
}

type UserConnection struct {
	PageInfo *PageInfo   `json:"pageInfo"`
	Edges    []*UserEdge `json:"edges"`
}

type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor string `json:"cursor"`
}

type UserFilter struct {
	ID                 *string            `json:"id"`
	Username           *StringFilter      `json:"username"`
	MatrixLinks        *StringArrayFilter `json:"matrixLinks"`
	PendingMatrixLinks *StringArrayFilter `json:"pendingMatrixLinks"`
	Admin              *bool              `json:"admin"`
}

type UserSort struct {
	ID       *SortRule `json:"id"`
	Username *SortRule `json:"username"`
	Admin    *SortRule `json:"admin"`
}

type SortDirection string

const (
	SortDirectionAsc  SortDirection = "ASC"
	SortDirectionDesc SortDirection = "DESC"
)

var AllSortDirection = []SortDirection{
	SortDirectionAsc,
	SortDirectionDesc,
}

func (e SortDirection) IsValid() bool {
	switch e {
	case SortDirectionAsc, SortDirectionDesc:
		return true
	}
	return false
}

func (e SortDirection) String() string {
	return string(e)
}

func (e *SortDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirection", str)
	}
	return nil
}

func (e SortDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
